
class Brutal_PlayerBase : PlayerPawn
{
	//=========================
	//Common
	//Movement General
	bool	Pain;
	double	ViewAngleDelta;
	float	ActualSpeed;
	float	MaxAirSpeed;
	float 	MaxGroundSpeed;
	float	MoveFactor;
	int		AnimateJump;
	int		ForceVelocity;
	int		MoveType;
	int		OldFloorZ;
	playerinfo ZMPlayer;
	vector2 OldVelXY;
	vector3	Acceleration;
	
	//////////////////
	
	//Jumping
	bool 	BlockJump;
	bool	Jumped;
	bool	doublejumpready;
	bool	alreadyjumped;
	bool	oldjump;
	float	FloorAngle;
	int		DoubleJumpCooler;
	int		JumpSoundCooler;
	
	//Double Jump
	bool	BlockDoubleJump;
	bool	CanDoubleJump;
	
	//Elevator Jumps
	float	ElevatorJumpBoost;
	int		OldSecIndex;
	
	//////////////////
	
	//Double Tap
	int		FirstTapTime;
	int		FirstTapValue;
	int		OldTapValue;
	
	//Dashing
	float	WJumpSpeed;
	int		DashNumber;
	int		DashCooler;
	
	//Air Dashing
	float	ADashTargetSpeed;
	int		ADashCooler;
	int		ADashFrictionDelay;
	
	//WallJump
	int		CheckForWJump;
	
	//WallSlideMove
	bool	CanWSlide;
	int		CheckForWSlide;
	vector2	WSlideVelocity;
	
	//Crouch Slide
	bool	CanCSlide;
	float	MaximumSlideSpeed;
	float	QSlideDuration;
	int		CSlideStartTime;
	
	//Ledge Grabbing
	bool	LedgeGrabbed;
	float	LedgeAngle;
	int		LedgeHeight;
	bool	LedgeCheck;
	int		LedgeTime;
	int		LedgeHeightMax;
	int		LedgeHeightMin;
	float	FrameTime;
	double	velx;
	double	vely;
	double	velz;
	weapon	ReselectWeapon;
	
	//Grappling Hook
	actor	GrappledMonster;
	actor	HookFired;
	bool	Grappled;
	float	PendulumLength;
	vector3	GrappleVel;
	vector3 Rope;
	int grapplesidespeed;
	double lasttickrope;
	
	//Booster Frame
	int boosttics;
	int boostlevel;
	int forwardtics;
	double lasttickvellength;
	bool booster;
	bool boostersound;
	float oldmaxstepheight;
	
	//////////////////
	
	//View Bobbing
	bool	PostLandingBob;
	float	ZMBob;
	
	//Weapon bobbing
	bool	DoBob;
	double	BobTime;
	double	HorizontalSway;
	double	BobRange;
	double 	OldTicFrac;
	double	VerticalOffset;
	
	//=========================
	//Painkiller only
	
	//Movement
	bool	TrickFailed;
	float	AirControl;
	float	ActualMaxAirSpeed;
	
	//Jumping
	float	TrickJumpAngle;
	int		SmallerJumpHeight;
	
	//=========================
	//Build Engine Only
	
	//Movement
	bool	DeepWater;
	float	LandingVelZ;
	int		FVel;
	int		SVel;
	int		UVel;
	
	int		DualTimer;
	Int		SpecialTimer;
	Int		GrenadeTimer;
	
	//Jumping
	int		BuildJumpDelay;
	
	
	//Saved morph stuff
	int PreMorphArmor;
	float PreMorphArmorPercent;
	int PreMorphHealth;
	
	bool notvoodoo;
	bool previouschasecam;
	
	//Soul granting
	
	int previouskills;
	int currentkills;
	
	//Merciless Extermination
	
	bool mercilessgranted;
	
	
	//Flashlight
	
	bool flashon;
	int flashtimer;
	int flashburnout;
	
	//Skulls
	bool spawnwitharmor;
	bool spawnberserked;
	bool shockfactor;
	bool istactical;
	bool oneupmanship;
	bool sequencebreak;
	bool maximumoverdrive;
	bool ultranightmare;
	int ultraseed;
	bool alreadyblacklisted;
	bool extralifegranted;
	bool reversalmodifier;
	
	bool scanneractive;
	int scannertimer;
	
	float lasttichealth;
	int paintimer;
	int healtimer;
	
	Default
    {
		Player.DisplayName "ZMovement Player";
        PainChance 255;
    }
	
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////																						////
	//// Non-Movement Stuff																		////
	////																						////
	////////////////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////////////////
	
	//Because GZDoom's Unit() returns NaN if a vector has no value
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	void togglescanner()
	{
		If(!scanneractive)
		{
			scanneractive = true;
			a_startsound("areascanner",122);
			//spawn("scannereffect",pos);
			
		}
		Scannertimer = 130;

	}
	
	Override int takespecialdamage(Actor inflictor, Actor source, int damage, Name damagetype)
		{
			If(inflictor is "grenadeexplosion" && source == self || inflictor is "leadburstertracer2")
			{
				Damage = (damage * 0.25);
			}
			If(source is "BDPBIKE" && !findinventory("veh_manager"))
				{
					damage = 0;
					SetStateLabel("pain.bikelaunch");
					
				}
			If(source is "Freezerbot" || source is "FreezeBot" || inflictor is "FreezeBot" || Inflictor is "Freezerbot")
				{
					damage = 0;
					
				}
			If(grappled)
				{
					Damage = (damage * 0.25);
				}
				
			return super.TakeSpecialDamage(inflictor, source, damage, damagetype);
				
		
		
		}
	
	Override void playerthink()
		{
		Super.playerthink();
		
		//Health Regen
		//console.printf("%i",health);	
		If(paintimer > 0)
		{
			paintimer--;
		}
		If(health < lasttichealth)
		{
			paintimer = 180;
			healtimer = 0;
		}
		lasttichealth = health;
		If(paintimer <= 0 && healtimer < 8)
		{
			healtimer++;
		}
		If(healtimer >= 8 && health < 20 && health > 0)
		{
			A_sethealth(health + 1);
			healtimer = 0;
		}
			
		
		takeinventory("PausePowerup",1);
		
		If(health >= 1)
		{
			If(scannertimer > 0)
			{
				scannertimer--;
			}
			Else
			{
				scanneractive = false;
			}
			If(flashtimer > 0)
			{
				flashtimer--;
			}
			
			If(flashburnout > 0)
			{
				flashburnout--;
			}
			
			If(findinventory("switchflashlight"))
			{
				If(flashon && !flashtimer)
				{
					flashon = false;
					A_startsound("FLASHOFF",5);
					A_takeinventory("BDP_flashlight",1);
					flashtimer = 20;
				}
				Else if(!flashtimer)
				{
					flashon = true;
					A_startsound("FLASHON",5);
					A_giveinventory("BDP_flashlight",1);
					flashtimer = 20;
					flashburnout = 700;
				}
				Takeinventory("switchflashlight",1);
			}
			
			If(flashon && !flashburnout)
				{
					flashon = false;
					A_startsound("FLASHOFF",5);
					A_takeinventory("BDP_flashlight",1);
					flashtimer = 20;
					Takeinventory("switchflashlight",1);
				}
			
		
		
		}
		
		currentkills = Level.Killed_monsters;
		If(currentkills > previouskills)
		{
			giveinventory("soulammo",(currentkills - previouskills));
			//console.printf("Soul Extracted");
		}
		previouskills = Level.Killed_monsters;
		
		If(currentkills == 0)
		{
			mercilessgranted = false;
		}
		If(!mercilessgranted && currentkills > 5 && currentkills >= Level.Total_Monsters)
		{
			mercilessgranted = true;
			A_Print("MERCILESS EXTERMINATION!",5);
			If(health < 100)
			{
				A_sethealth(100);
			}
			A_startsound("ALLKILL",227,CHANF_LOCAL,1.0,ATTN_NONE);
			If(random(0,50) == 5)
			{
				A_startsound("YIPPEE",228,CHANF_LOCAL,1.0,ATTN_NONE);
			}
			
		}
		
		If(ultranightmare && !ultraseed)
		{
		
			string data = bdp_seed_blacklist;
			Array<string> blacklist;
			data.Split(blacklist,",");
			
			int ultraseedcandidate = random(1,99999999999);
			bool candidatetaken;
			for(int i=0; i<blacklist.Size(); i++)
			{	
				int blacklistint = (blacklist[i].ToInt(10));
				//console.printf("%i",blacklistint);
				If(blacklistint == ultraseedcandidate)
				{
					candidatetaken = true;
				}
			
			}
			If(!candidatetaken)
			{
				ultraseed = ultraseedcandidate;
				//console.printf("%i",ultraseed);
			}
				
			
		}
		
		if(ultraseed)
		{
			
			If((health < 1) && !alreadyblacklisted)
			{
				A_Print("\cgThe nightmare has ended.",999);
				ACS_NamedExecuteAlways("BDNightmareDeath", 0, 0, 0, 0);
				string ultraseedstring = (string.format("%i", ultraseed));
				//Console.printf(ultraseedstring);
				let sv_blacklist = CVar.GetCVar("bdp_seed_blacklist", players[consoleplayer]);

				if(bdp_seed_blacklist == "") 
				sv_blacklist.SetString(ultraseedstring);
				else
				sv_blacklist.SetString(String.Format("%s, %s", bdp_seed_blacklist, ultraseedstring));
				//console.printf("%s, %s", bdp_seed_blacklist, ultraseedstring);
				Alreadyblacklisted = true;
			}
			
			
			If((health >= 1))
			{
				string data = bdp_seed_blacklist;
				Array<string> blacklist;
				data.Split(blacklist,",");
				for(int i=0; i<blacklist.Size(); i++)
				{	
					int blacklistint = (blacklist[i].ToInt(10));
					//console.printf("%i",blacklistint);
					If(blacklistint == ultraseed)
					{
						//candidatetaken = true;
						damagemobj(null,null,9999999,"explosiveimpact");
						A_Print("\cgThe nightmare has ended.",999);
						ACS_NamedExecuteAlways("BDNightmareLoad", 0, 0, 0, 0);
						//S_ChangeMusic("ORB");
						Alreadyblacklisted = true;
						//console.printf("FAGGOT");
					}
			
				}
			}
			
		}	
		
		if(ultranightmare && oneupmanship && !extralifegranted)
		{
			A_giveinventory("extralife",3);
			Extralifegranted = true;
		}
		
		If(spawnwitharmor && !findinventory("powershield",TRUE) && health > 0)
		{
			GiveInventory("PowerShield2",1);
			If(countinv("basicarmor") < 50)
			{
				takeinventory("basicarmor",50);
				GiveInventory("mjolnirarmor",50);
			}
		}
		
		If(spawnberserked && !findinventory("powerstrength",TRUE) && health > 0)
		{
			GiveInventory("Berserk2",1);
			If((health) < 50)
			{
				a_sethealth(100);
			}
		}
		
		If(maximumoverdrive && !findinventory("powerboost",TRUE) && health > 0)
		{
			GiveInventory("boosterframe",1);
		}
		
		If(sequencebreak && !findinventory("sequencebreaker"))
		{
			GiveInventory("SequenceBreaker",1);
		}
		
		
		If(shockfactor && level.time % 5 == 0)
		{
			A_alertmonsters(0,AMF_TARGETEMITTER);
		}
		
		If(reversalmodifier && !findinventory("canparry",TRUE) && health > 0)
		{
			GiveInventory("canparry",1);
		}
		
		If(countinv("extralife") > 0)
		{
			bbuddha = true;
			If((health) <= 1)
			{
				a_sethealth(100);
				A_takeinventory("extralife",1);
				A_giveinventory("miniinvul",1);
				A_startsound("items/soulsphere",212);
			}
		}
		Else
		{
			bbuddha = false;
		}
		
		//giveinventory("meathook",1);
		If (istactical)
		{
		Giveinventory("istacticalclass",1);
		Takeinventory("isnottacticalclass",1);
		}
		Else
		{
		Giveinventory("isnottacticalclass",1);
		Takeinventory("istacticalclass",1);
		}
		If(dualtimer >= 1)
		{
		Dualtimer = dualtimer - 1;
		}
		
		If(specialtimer >= 1)
		{
		Specialtimer = specialtimer - 1;
		}
		
		If(Grenadetimer >= 1)
		{
		Grenadetimer = Grenadetimer - 1;
		}
		
		If(health < 1)
		{
		A_stopsound(125);
		A_stopsound(126);
		}
		
		If(player.cmd.buttons & BT_USER3 && dualtimer <= 0)
			{
			dualtimer = 17;
			giveinventory("startdualwield",1);
			}
		If(player.cmd.buttons & BT_USER4 && specialtimer <= 0)
			{
			specialtimer = 17;
			giveinventory("swapriflespecial",1);
			}
		If(player.cmd.buttons & BT_USER2 && grenadetimer <= 0)
			{
			grenadetimer = 8;
			giveinventory("TossGrenade",1);
			}
		If(player.cmd.buttons & BT_ATTACK)
			{
			giveinventory("firedprimary",1);
			}
	
		
		}
	
	
	Override void HandleMovement() { 
	
		
		notvoodoo = true;
		
		if(GetCvar("donotclimb") == 0) 
		{
			If(LedgeCheck)
			{
				if(countinv("usedstamina") < 60)
				{	
					LedgeReach();
				
				
				}
				Else
				{
					A_startSound("Tired", 21,CHANF_NOSTOP);
				}
			}
			if(LedgeGrabbed)
			{
				LedgeGrab();
			}
			LedgeGrabInitiator();
		}
		if(GetCVAR("donotdoublejump") == 0) 
		{
			//CheckJump();
		}
		if(GrappleVel.Length())
			{
				takeinventory("meathook",1);
				GrapplingMove();
			}
		Else
			{
				giveinventory("meathook",1);
				Grappled = False; 
			}
			
		super.HandleMovement();
		
	}
	
	override void moveplayer()
	{
		let player = self.player;
		UserCmd cmd = player.cmd;
		If(countinv("powerboost") > 0)
		{
			Booster = true;
		}
		Else
		{
			Booster = false;
		}

		
		// [RH] 180-degree turn overrides all other yaws
		if (player.turnticks)
		{
			player.turnticks--;
			Angle += (180. / TURN180_TICKS);
		}
		else
		{
			Angle += cmd.yaw * (360./65536.);
		}

		player.onground = (pos.z <= floorz) || bOnMobj || bMBFBouncer || (player.cheats & CF_NOCLIP2);

		// killough 10/98:
		//
		// We must apply thrust to the player and bobbing separately, to avoid
		// anomalies. The thrust applied to bobbing is always the same strength on
		// ice, because the player still "works just as hard" to move, while the
		// thrust applied to the movement varies with 'movefactor'.
		
		If(player.onground)
		{
			takeinventory("jetpackmoving",1);
		}
		
		Bool jetpacking = countinv("jetpackmoving");
		
		If(booster && cmd.forwardmove && cmd.buttons & BT_SPEED && countinv("StaminaExhaustion") < 1)
		{
			boosttics++;
			If(boosttics >= 20)
			{
				boostlevel++;
				boosttics = 0;
			}
		}
		Else if (boostlevel > 0)
		{
			boosttics++;
			If(boosttics >= 5)
			{
				boostlevel--;
				boosttics = 0;
			}
			If(!cmd.forwardmove)
			{
				forwardtics--;
				//console.printf("%i",forwardtics);
				If(forwardtics < -5)
				{
					boostlevel = 0;
					forwardtics = 0;
				}
			}
		}
		Else
		{
			boosttics = 0;
		}
		
		If (boostlevel > 9)
		{
			Boostlevel = 9;
		}
		//console.printf("%i",boostlevel);
		If(boostlevel > 1 && !boostersound)
		{
			Boostersound = true;
			A_startsound("BSTRSTRT",127);
			A_startsound("BSTRLoop",128,CHANF_LOOPING);
			//A_startsound("BSTRWind",129,CHANF_LOOPING);
			oldmaxstepheight = maxstepheight;
			maxstepheight = (maxstepheight * 2);
		}
		Else if (boostlevel < 2 && boostersound)
		{
			boostersound = false;
			A_StartSound("BSTRStop",127);
			A_stopsound(128);
			A_StopSound(129);
			maxstepheight = oldmaxstepheight;
		}
		
		if (cmd.forwardmove | cmd.sidemove)
		{
			double forwardmove, sidemove;
			double bobfactor;
			double friction, movefactor;
			double fm, sm;

			[friction, movefactor] = GetFriction();
			bobfactor = friction < ORIG_FRICTION ? movefactor : ORIG_FRICTION_FACTOR;
			if (!player.onground && !bNoGravity && !waterlevel && !jetpacking && !rope.length())
			{
				// [RH] allow very limited movement if not on ground.
				movefactor *= level.aircontrol;
				bobfactor*= level.aircontrol;
			}

			fm = cmd.forwardmove;
			sm = cmd.sidemove;
			[fm, sm] = TweakSpeeds (fm, sm);
			fm *= Speed / 256;
			sm *= Speed / 256;

			// When crouching, speed and bobbing have to be reduced
			if (CanCrouch() && player.crouchfactor != 1)
			{
				fm *= player.crouchfactor;
				sm *= player.crouchfactor;
				bobfactor *= player.crouchfactor;
			}
			
			If(boostlevel >= 1)
			{
				fm = fm + (boostlevel * 10);
			}

			forwardmove = fm * movefactor * (35 / TICRATE);
			sidemove = sm * movefactor * (35 / TICRATE);

			if (forwardmove)
			{
				Bob(Angle, cmd.forwardmove * bobfactor / 256., true);
				ForwardThrust(forwardmove, Angle);
			}
			if (sidemove)
			{
				let a = Angle - 90;
				Bob(a, cmd.sidemove * bobfactor / 256., false);
				Thrust(sidemove, a);
			}

			if (!(player.cheats & CF_PREDICTING) && (forwardmove != 0 || sidemove != 0))
			{
				PlayRunning ();
			}

			if (player.cheats & CF_REVERTPLEASE)
			{
				player.cheats &= ~CF_REVERTPLEASE;
				player.camera = player.mo;
			}
			
			If(jetpacking)
			{
				vel.xy *= 0.97;
			}
			
		}
		/*
		If(boostlevel > 7 && !checkmove(Pos.XY + AngleToVector(angle, 16), PCM_NOACTORS))
		{
			
			A_stop();
			A_recoil(14);
			vel.z = 10;
			A_Quake(boostlevel,12,0,800);
			boostlevel = 0;
			boosttics = 0;
			A_startsound("skeleton/melee",28);
			
			
		}
		*/
		
		lasttickvellength = vel.length();
		
		If(boostlevel > 1)
		{
			If(sequencebreak)
			{
				BDP_DoorBuster.DestroyDoor(self,  breakLocks: BDP_DoorBuster.LB_All);
			}
			Else
			{
				BDP_DoorBuster.DestroyDoor(self,  breakLocks: BDP_DoorBuster.LB_CheckKey);
			}
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			a_spawnitemex("Speedline",140,frandom(40,-40),frandom(0,80),vel.x,vel.y,vel.z,0,SXF_ABSOLUTEVELOCITY);
			
			Actor speedMo = Spawn("PlayerSpeedTrail", Pos, NO_REPLACE);
			if (speedMo)
			{
				speedMo.Angle = Angle;
				speedMo.Translation = Translation;
				speedMo.target = Self;
				speedMo.sprite = sprite;
				speedMo.frame = frame;
				speedMo.Floorclip = Floorclip;

				// [BC] Also get the scale from the owner.
				speedMo.Scale = Scale;

				if (Self == players[consoleplayer].camera &&
					!(player.cheats & CF_CHASECAM))
				{
					speedMo.bInvisible = true;
				}
			}
		}
	
	}
	override void CheckJump()
	{
		
		let player = self.player;
		// [RH] check for jump
		If(!player.onground && !doublejumpready && !oldjump)
		{
			doublejumpready = true;
		
		}
		Else if(player.onground)
		{
			doublejumpready = false;
			oldjump = false;
			alreadyjumped = false;
		}
		
		if (player.cmd.buttons & BT_JUMP)
		{
			if (player.crouchoffset != 0)
			{
				// Jumping while crouching will force an un-crouch but not jump
				player.crouching = 1;
			}
			else if (waterlevel >= 2)
			{
				Vel.Z = 4 * Speed;
			}
			else if (bNoGravity)
			{
				Vel.Z = 3.;
			}
			else if (player.onground && player.jumpTics == 0 || doublejumpready && !oldjump && !alreadyjumped && !(player.readyweapon is "hellishmissilelauncher" && countinv("gas") > 0))
			{
				double jumpvelz = JumpZ * 35 / TICRATE;
				double jumpfac = 0;

				// [BC] If the player has the high jump power, double his jump velocity.
				// (actually, pick the best factors from all active items.)
				for (let p = Inv; p != null; p = p.Inv)
				{
					let pp = PowerHighJump(p);
					if (pp)
					{
						double f = pp.Strength;
						if (f > jumpfac) jumpfac = f;
					}
				}
				if (jumpfac > 0) jumpvelz *= jumpfac;

				Vel.Z = jumpvelz;
				Vel.z += (vel.xy.length() * 0.25);
				//console.printf("%i",vel.z);
				bOnMobj = false;
				player.jumpTics = -1;
				if (!(player.cheats & CF_PREDICTING)) A_StartSound("*jump", CHAN_BODY);
				If(doublejumpready)
				{
					alreadyjumped = true;
				}
				oldjump = true;
			}
		}
		Else if (oldjump)
		{
			oldjump = false;
		}
	}
	
	override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		UserCmd cmd = player.cmd;

		if (cmd.buttons & BT_JUMP)
		{
			cmd.buttons &= ~BT_CROUCH;
		}
		if (CanCrouch() && player.health > 0)
		{
			if (!totallyfrozen)
			{
				int crouchdir = player.crouching;

				if (crouchdir == 0)
				{
					crouchdir = (cmd.buttons & BT_CROUCH) ? -1 : 1;
				}
				else if (cmd.buttons & BT_CROUCH)
				{
					player.crouching = 0;
				}
				if (crouchdir == 1 && player.crouchfactor < 1 && pos.Z + height < ceilingz)
				{
					CrouchMove(1);
				}
				else if (crouchdir == -1 && player.crouchfactor > 0.5)
				{
					CrouchMove(-1);
				}
			}
		}
		else
		{
			player.Uncrouch();
		}

		player.crouchoffset = -(ViewHeight) * (1 - player.crouchfactor);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		bool allclear;
		
		If(boostlevel > 1 && other)
		{
			If(findinventory("powerstrength"))
			{
				other.damagemobj(self,self,boostlevel * 8,"extremepunches");
			}
			
			else
			{
				other.damagemobj(self,self,boostlevel * 4,"extremepunches");
			}
			if(other && !other.bnodamagethrust && other.mass <  9999)
			{
				float yeetangle = angleto(other);
				other.velfromangle(boostlevel * 5,yeetangle);
				other.vel.z = 6;
				allclear = true;
			}
		}
		
		If(!allclear)
			{
			Return True;
			}
		Else
		{
			Return False;
		}
		
	}
	
	
	bool HookLOS()
	{
		Float LOSPitch = atan2(Rope.XY.Length(), Rope.Z) - 90;
		Float LOSAngle = VectorAngle(Rope.X, Rope.Y);
		FLineTraceData LOSCheck; LineTrace(LOSAngle, Rope.Length(), LOSPitch, TRF_SOLIDACTORS|TRF_BLOCKSELF, Height / 2.f, data: LOSCheck);
		
		if(GrappledMonster != Null && LOSCheck.HitActor == GrappledMonster) { return true; }
		
		return LOSCheck.Distance == Rope.Length();
	}
	
	void GrapplingMove()
	{
		/*if(!brutal_playerbase.OnGround) */{ Grappled = True; }
		
		//Fun is over kids, go home
		if(bNOGRAVITY || Rope.Length() <= 4.f * Radius || !CheckMove(Pos.XY + Vel.XY) || (lasttickrope && rope.length() > (lasttickrope + 30)))
		{
			StopHook();
			return;
		}
		lasttickrope = rope.length();
		
		Usercmd cmd = player.cmd;
			GrappleVel = SafeUnit3(Rope) * GrappleVel.Length();
			Vel = GrappleVel;
			If(cmd.sidemove > 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			else if(cmd.sidemove < 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Acceleration.XY = RotateVector((0, -grapplesidespeed), Angle);
			//
			double currentvel = vel.length();
			vel.xy = (vel.xy + acceleration.xy);
			
			
			//console.printf("%i",rope.length());
			If(!cmd.sidemove && grapplesidespeed > 0)
			{
				grapplesidespeed = grapplesidespeed - 2;
			}
			Else if (!cmd.sidemove && grapplesidespeed < 0)
			{
				grapplesidespeed = grapplesidespeed + 2;
			}
			
	}
	
			
		void StopHook()
	{
		Rope = GrappleVel = (0, 0, 0);
		PendulumLength = 0;
		GrappledMonster = Null;
		grapplesidespeed = 0;
		lasttickrope = 0;
		
	}
		
		//QuakeHandleMove();
		
		//Sprite animation
		//Super.handlemovement();
	
	
	Override void Tick()
    {
	If(findinventory("veh_manager"))
		{
		SetPlayerProperty(0,0,0);
		player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState('InAVehicle'));
		SetStateLabel("invehicle");
		bpickup = false;
		}
		Else
		{
		bpickup = true;
		//if (GetCvar("bd_GenderFemale") == 1) {
		//if (CountInv("GenderFemale") == 1) {
		//	SoundClass = "fplayer";
		//}
		If(CountInv("RollingRight") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingright");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollingLeft") == 1)
		{
		//player.cheats |= CF_CHASECAM;
		SetStateLabel("rollingLeft");
		bforcexybillboard = TRUE;
		}
		If(CountInv("RollFinished") == 1)
		{
		//player.cheats &= ~CF_CHASECAM;
		takeinventory("rollfinished",1);
		bforcexybillboard = FALSE;
		}
		if (CountInv("ExecuteDownedEnemy") == 1)
        {
           TakeInventory("ExecuteDownedEnemy", 10);
		   TakeInventory("GoSpecial", 10);
            player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoExecution"));
		//	TakeInventory("ExecuteDownedEnemy", 1);
		//   TakeInventory("GoSpecial", 1);
			SetStateLabel("SpecialChecker");
        }
		
		/*
		if (CountInv("DoStrengthRuneAnim") == 1) {
			TakeInventory("DoStrengthRuneAnim", 1);
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("DoStrengthRuneAnim"));
		}
		*/
		
		If(player && notvoodoo && findinventory("nottitlemap"))
			{
				
		
			let playerArmor = BasicArmor(FindInventory('BasicArmor'));
			If(player && findinventory('ReturnUnmorphStuffPlease'))
				{
				takeinventory('ReturnUnmorphStuffPlease',1);
				
					playerarmor.amount = PreMorpharmor;
					playerArmor.SavePercent = PreMorphArmorPercent;
					a_sethealth(premorphhealth);
				}
	
		
			PreMorphArmor = playerarmor.amount;
			PreMorphArmorPercent =	playerArmor.SavePercent;
			PreMorphHealth = health;
			
			}
			
		}
		super.Tick();
    }
	
	
	//////////////////////////////////////
	// Ledge Grab						//
	//////////////////////////////////////
	
	void LedgeGrabInitiator()
	{
		ZMPlayer = self.player;
		
		//Already ledge grabbing, no clipping, moving away from where you are looking, ceiling already too low for sure
		if((pos.z <= floorz) || LedgeCheck || LedgeGrabbed || (ZMPlayer.Cheats & CF_NOCLIP2) || Vel.XY dot AngleToVector(Angle) <= 0 || CeilingZ <= Pos.Z + Height * 1.6f) { return; }
		
		//============================================
		//Find ledge (if any)						//
		//============================================
		
		FLineTraceData LedgeTrace;
		Float TraceDistance = sqrt(2) * Radius + 1; //account for the fact that Doom's hitboxes are square
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS, Height * 1.2f, data: LedgeTrace);
		Vector3 HitPos = LedgeTrace.HitLocation;
		
		Int LedgeCandidate;
		if(LedgeTrace.HitType == TRACE_HitWall) //hit wall scenario
		{
			if(LedgeTrace.Hit3DFloor != NULL) //3D floor
			{
				LedgeCandidate = LedgeTrace.Hit3DFloor.Top.ZAtPoint(HitPos.XY);
			}
			else //regular wall
			{
				Line HitLine = LedgeTrace.HitLine;
				if(HitLine.FrontSector != NULL && HitLine.FrontSector != CurSector)
					LedgeCandidate = HitLine.FrontSector.FloorPlane.ZatPoint(HitPos.XY);
				else if(HitLine.BackSector != NULL && HitLine.BackSector != CurSector)
					LedgeCandidate = HitLine.BackSector.FloorPlane.ZatPoint(HitPos.XY);
			}
		}
		else if(LedgeTrace.HitSector != CurSector)//tracer stopper mid air in a sector that is not the one where player currently is
		{
			LedgeCandidate = LedgeTrace.HitSector.NextLowestFloorAt(HitPos.X, HitPos.Y, HitPos.Z, FFCF_3DRESTRICT, 0);
		}
		else
		{
			return;
		}
		
		//Check if the candidate ledge can suffice
		if(LedgeCandidate > Pos.Z + Height * 0.6f && LedgeCandidate <= Pos.Z + Height * 1.2f)
		{
			Vector3 OrigPos = Pos;
			SetXYZ((Pos.XY, LedgeCandidate));
			if(!CheckMove(Pos.XY + 5.f * AngleToVector(Angle))) //not enough space, cancel everything :(
			{
				SetXYZ(OrigPos);
				return;
			}
			SetXYZ(OrigPos);
			LedgeHeight = LedgeCandidate;
			LedgeHeightMin = (LedgeHeight - Height * 0.97f);
			LedgeHeightMax = (LedgeHeight - Height * 0.751f);
		}
		else
		{
			return; //too high/low
		}
		
		/*
		LineTrace(Angle, TraceDistance, 0, TRF_BLOCKSELF|TRF_THRUACTORS|TRF_NOSKY, 0, data: LedgeTrace);
		if (LedgeTrace.HitLine && LedgeTrace.hittype == TRACE_HITWALL) 
		{
			double lineangle = atan2(LedgeTrace.HitLine.delta.y, LedgeTrace.HitLine.delta.x); //angle of the line
			double targangle = lineangle + 90; //this will be the angle of the player
			
			if(targangle < 0) 
			{
				targangle = -(targangle + 90);
			}
			if (LedgeTrace.LineSide)
			{
				targangle *= -1; //reverse it if you're facing the back side of the linedef
			}
			A_SetAngle(targangle,SPF_INTERPOLATE); //set player's angle
		}
		*/
		
		//============================================
		//Abemus ledge, execute						//
		//============================================
		
		//Switch to a weapon that forbids firing during the ledge grab
		
		/*
		//Reset dash stuff just in case
		//MaxAirSpeed = ADashTargetSpeed;
		//DashCooler = ADashCooler = ADashTargetSpeed = WJumpSpeed = DashNumber = 0;
		*/
		
		//Credit Cherno
		//Console.Printf("Num: %f", LedgeHeight);
		
		velz = 8;
		LedgeCheck = True;
		
		if(vel.length() < 5)
		{
			GiveInventory("Grabbing_A_Ledge", 1);
		}
		if(pos.z >= (LedgeHeightMin+20))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("FinishClimb"));
			
			A_StopSound(CHAN_WEAPON);
			A_StartSound("ledgeclimb");
			LedgeAngle = Angle;
			LedgeCheck = False;
			LedgeGrabbed = True;
			return;
		}
		if((player.readyweapon is "Melee_Attacks") || (player.readyweapon is "Chain_saw") || (player.readyweapon is "BrutalAxe"))
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("StainedLedgeClimb"));
		}
		else
		{
			player.SetPSprite(PSP_WEAPON,player.ReadyWeapon.FindState("LedgeClimb"));
		}
	}
	void LedgeReach()
	{
		LedgeTime++;
		if(LedgeTime >= 30)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
	}
	
	void LedgeGrab()
	{
		if(Pos.Z >= LedgeHeight || !Vel.Length() || LedgeTime >= 35)
		{
			//End Ledge Grab
			LedgeCheck = False;
			SetOrigin((Pos.X, Pos.Y, LedgeHeight), True);
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			
			//Only if ledge grab was successful
			if(LedgeTime >= 35) { return; }
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
			Vel = Vel.Length() ? (5.f * AngleToVector(LedgeAngle), -3) : (0, 0, 0); //push player forward and downward
			A_StartSound("*land", CHAN_BODY);
		}
		else
		{
			Vel = Vel.Length() ? (0, 0, 8) : (0, 0, 0);
		}
		
		//Fail safe to unlock player movement if something goes wrong
		LedgeTime++;
		if(LedgeTime >= 35)
		{
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
			LedgeGrabbed = LedgeTime = LedgeHeight = LedgeHeightMin = LedgeHeightMax = FrameTime = 0;
		}
		
		//Sprite animation
		PlayIdle();
	}
}


Class Hook : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+HITMASTER;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		//+alwayspuff;
		+puffonactors;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		//+seekermissile;
		//+screenseeker;
		//+doombounce;
		//+bounceonfloors;
		//+bounceonwalls;
		+dontcorpse;
		+explodeonwater;
		//+noclip;
		Damagefunction 0;
		+nodamagethrust;
		Height 4;
		Radius 10;
		Speed 1;
		Species "Hook";
		+puffgetsowner;
	//	+forcepain; 
		//bouncefactor 0.1;
		+NOTIMEFREEZE;
	}
	
	vector3 HookToPlayer;
	vector3	HookToMonster;
	int		MonsterSpeed;
	int		MonsterFloatSpeed;
	float maxdistnew;
	//bool bisflaming;
	
	vector3 SafeUnit3(Vector3 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	vector2 SafeUnit2(Vector2 VecToUnit)
	{
		if(VecToUnit.Length()) { VecToUnit /= VecToUnit.Length(); }
		return VecToUnit;
	}
	
	Override void Tick()
	{
		//bool isflaming = false;
		Let HookOwner = brutal_playerbase(Target);
		if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
		}
		
		Super.Tick();
		
		UpdateTrail();
	}
	
	void UpdateTrail()
	{
		int b;
		for(b = 1; b <= 14; b++)
		{
			ActorIterator BallOfSteele = Level.CreateActorIterator(84115 + b);
			Actor Ball = BallOfSteele.Next();
			
			if(Ball != Null)
			{
				//Set trail velocity
				Vector3 TargetPos = Pos - (HookToPlayer * b / 15.f);
				Ball.Vel = TargetPos - Ball.Pos;
			}
		}
	}
	
	void InitiateGrapple(Bool Monster)
	{
		Let HookOwner = brutal_playerbase(Target);
		
		Float	PushLength = 4 * 5.5;
		Vector3 HookPush = SafeUnit3(HookToPlayer) * PushLength;
		Float 	HookSpeed = max((HookPush).Length(), PushLength);
		HookOwner.Rope = HookToPlayer; //needed for the LOS check
		
		//Check hook is still in sight
		//if(!HookOwner.HookLOS())
		//{
		//	SetState(FindState("DespawnHook"));
		//	return;
		//}
		
		//Stop any eventual wall slides
		/*
		HookOwner.StopWSlide();
		
		//Stop dashing stuff
		HookOwner.ADashCooler = HookOwner.ADashTargetSpeed = 0;
		
		//Initiate hook
		*/
		HookSpeed = HookOwner.MaxAirSpeed = min(HookSpeed, 24);
		HookOwner.Vel = HookOwner.GrappleVel = HookSpeed * SafeUnit3(HookPush);
		
		//Hooking monsters specific
		if(Monster)
		{
			Let Monster = Actor(Master);
			If(!monster.bnoblood)
			{
			Monster.spawnblood(pos,angle,1);
			}
			monster.a_pain();
			brutal_playerbase(Target).GrappledMonster = Monster;
			SetMonsterSpeed(False);
			A_StartSound("HookMeat", 7);
		}
		else
		{
			A_StartSound("HookWall", 7);
		}
	}
	
	void SetMonsterSpeed(Bool Reset)
	{
		Let Monster = Actor(Master);
		/*
		if(!Reset)
		{
			MonsterSpeed = Monster.Speed;
			MonsterFloatSpeed = Monster.FloatSpeed;
			Monster.Speed = Monster.FloatSpeed = 0;
		}
		else
		{
			Monster.Speed = MonsterSpeed;
			Monster.FloatSpeed = MonsterFloatSpeed;
		}
		*/
	}
	
	void SpawnTrail()
	{
		int h;
		for(h = 1; h <= 14; h++)
		{
			
			A_SpawnItemEx("HookTrail",0,0,0,0,0,0,0,SXF_ISTRACER|SXF_SETTARGET|SXF_ORIGINATOR|SXF_NOCHECKPOSITION);
			
			
			Let SlaveTrail = HookTrail(Tracer);
			SlaveTrail.ChangeTid(84115 + h);
		}
	}
	
	
	

	
	States
	{
	//====================================
	//Hook is traveling through space
	Spawn:
		OCLW A 0 NoDelay
		{
			Let HookOwner = brutal_playerbase(Target);
			A_AlertMonsters();
			
			 if (target && target.target)
			 {//ensure that the shooter even has a target
            SetOrigin(target.target.pos+(0,0,target.target.height*0.5),false);
			target.a_cleartarget();
			}
			SpawnTrail();
			//HookOwner.a_takeinventory("meathook",1);
			
		}
	Looper:
		OCLW A 1
		{
			//a_seekermissile(365,365,SMF_LOOK);
			Let HookOwner = brutal_playerbase(Target);
			//target.giveinventory("meathook",1);
			//Despawn if no geometry was found
			/*
			if(HookToPlayer.Length() >= 1300.f || !HookOwner)
			{
				SetState(FindState("Death"));
				return;
			}
			*/
		}
		Goto despawnhook;
	
	//====================================
	//Hook hit a wall or ceiling

	
	
	TillDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			if(!HookOwner.GrappleVel.Length() || !HookOwner)
			{
				SetState(FindState("DespawnHook"));
				return;
			}
			
			if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
		}
		
		
		UpdateTrail();
			
			HookOwner.Rope = HookToPlayer;
		}
		Loop;
		
	//====================================
	//Hit actor
	XDeath:
	//Melee:
		OCLW A 1
		{

			
			Let HookOwner = brutal_playerbase(Target);
			//SpawnTrail();
			Let Monster = Actor(Master);
			
		
			
			InitiateGrapple(True); 
			maxdistnew = HookToPlayer.length();
		}
	
	TillXDeathDoesUsApart:
		OCLW A 1
		{
			Let HookOwner = brutal_playerbase(Target);
			Let Monster = Actor(Master);
			If (monster)
			{
			setorigin(monster.pos+(0,0,monster.height*0.5),TRUE);
			}
			
			if(!HookOwner || !HookOwner.GrappleVel.Length() || !Monster || Monster.health <=0)
			{
				return resolvestate("despawnhook");
			}
			
			
				if(HookOwner)
		{
			Vector3 WaistPos = (HookOwner.Pos.X, HookOwner.Pos.Y, HookOwner.Pos.Z + HookOwner.Height / 2.f); // player position
			HookToPlayer = Pos - WaistPos; //hook-to-player vector
			
			
			
			
		}
		
		
		UpdateTrail();
			
			
			a_startsound("MHKLOOP",194,CHANF_LOOPING,0.5,ATTN_NONE);
			/*
			if (monster.FindState('Pain.meathook') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain.meathook");
			}
			Else if (monster.FindState('Pain') && !monster.bdormant && !monster.bnopain && !monster.findinventory("glorykillme") && !monster.findinventory("enemyisarchvile"))
			{
			Monster.setstatelabel("pain");
			}
			*/
			
			
			Vel = Monster.Vel;
			HookOwner.Rope = HookToPlayer;
			Return resolvestate(null);
		}
		Loop;
		
	//====================================
	//Die Monster! You don't belong in this world
	Death:
	OCLW AAA 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
			//	HookOwner.a_giveinventory("canfiremeathook",1);
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("meathook",1);
				//HookOwner.a_startsound("weapons/empty",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
		
	DespawnHook:
		OCLW A 0
		{
			Let HookOwner = brutal_playerbase(Target);
			if(HookOwner)
			{
				HookOwner.StopHook();
			//	HookOwner.a_giveinventory("canfiremeathook",1);
			//	HookOwner.a_giveinventory("meathook",1);
				HookOwner.a_startsound("MHKSTP",194,CHANF_DEFAULT,1,ATTN_NONE);
			}
			a_stopsound(194);
			Let Monster = Actor(Master);
			if(Monster && MonsterSpeed) { SetMonsterSpeed(True); }
		}
		Stop;
	}
}

Class HookTrail : Actor
{
	Default
	{
		+FORCEXYBILLBOARD;
		+MISSILE;
		+NOGRAVITY;
		+NOTELEPORT;
		+NOTONAUTOMAP;
		+THRUSPECIES;
		+ExplodeOnWater;
		Radius 2;
		Height 4;
		Scale 0.5;
		Species "HookTrail";
		+NOTIMEFREEZE;
	}
	
	States
	{
		Spawn:
		Looper:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
				
			
			}
			Loop;
			
		Death:
			TEND A 1
			{
				if(!Hook(Target))
				{
					SetState(FindState("DespawnTrail"));
					return;
				}
			}
			Loop;
			
		DespawnTrail:
			Stop;
	}
}

Class Speedline : Actor
{
	Default
	{
		+nogravity;
		Renderstyle "Add";
		Alpha 0.2;
		+noteleport;
		+noclip;
	}
	
	States
	{
		Spawn:
			TNT1 A 0 NODELAY A_recoil(30);
			TRAC A 5;
			Spawn2:
			TRAC A 1 A_FadeOut(0.10);
			LOOP;
	
	}

}

//DarkDoomZ flashlight!

class BDP_Flashlight : CustomInventory {
	BDP_Spotlight SelfLight1, SelfLight2;
	bool Active;
	int Quality,OldQuality;
	int Type,OldType;
	int Mount,OldMount;
	int R,G,B;
	int beamInner, beamOuter, beamRadius;
	int spillInner, spillOuter, spillRadius;
	double offsetAngle, offsetZ;
	int inertia;
	double spring, damping;

	default {
		+INVENTORY.PERSISTENTPOWER;
		+inventory.autoactivate;
	}
	Override void detachfromowner()
	{
	
	if(SelfLight1) { SelfLight1.Destroy(); }
	if(SelfLight2) { SelfLight2.Destroy(); }
	Super.detachfromowner();
	}

	override void DoEffect() {
		super.DoEffect();
		
				
				if(SelfLight1) { SelfLight1.Destroy(); }
				if(SelfLight2) { SelfLight2.Destroy(); }
			

			
				//	R = 255;
				//	G = 214;
				//	B = 170;
				//	beamInner = 0;
				//	beamOuter = 25;
				//	beamRadius = 384;
					//spillInner = 15;
				//	spillOuter = 45;
				//	spillRadius = 128;
				//	break;
				//case 1: //Halogen
					R = 255;
					G = 237;
					B = 162;
					beamInner = 0;
					beamOuter = 20;
					beamRadius = 512;
					spillInner = 10;
					spillOuter = 60;
					spillRadius = 384;
					//break;
				/*case 2: //LED
					R = 248;
					G = 255;
					B = 255;
					beamInner = 0;
					beamOuter = 15;
					beamRadius = 640;
					spillInner = 15;
					spillOuter = 75;
					spillRadius = 256;
					break;
				case 3: //Red filter
					R = 192;
					G = 36;
					B = 34;
					beamInner = 0;
					beamOuter = 20;
					beamRadius = 256;
					spillInner = 10;
					spillOuter = 60;
					spillRadius = 128;
					break;
					*/
			

			/*
				case 0: //Handheld
					spring = 0.25;
					damping = 0.2;
					inertia = 4;
					offsetAngle = 0;
					offsetZ = -13;
					break;
				case 1: //Left Shoulder
					spring = 0.35;
					damping = 0.75;
					inertia = 2;
					offsetAngle = 80;
					offsetZ = -5;
					break;
				case 2: //Right Shoulder
					spring = 0.35;
					damping = 0.75;
					inertia = 2;
					offsetAngle = -80;
					offsetZ = -5;
					break;
				case 3: //Helmet
				*/
					spring = 1;
					damping = 1;
					inertia = 1;
					offsetAngle = 0;
					offsetZ = 4;
					//break;
			

			
					if(!SelfLight1) {
						SelfLight1 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight1.FollowTarget = owner;
						SelfLight1.args[DynamicLight.LIGHT_RED] = R; //R
						SelfLight1.args[DynamicLight.LIGHT_GREEN] = G; //G
						SelfLight1.args[DynamicLight.LIGHT_BLUE] = B; //B
						SelfLight1.args[DynamicLight.LIGHT_INTENSITY] = (beamRadius + spillRadius) / 2; //Radius
						SelfLight1.SpotInnerAngle = (beamInner + spillInner) / 2;
						SelfLight1.SpotOuterAngle = (beamOuter + spillOuter) / 2;
						SelfLight1.angle = owner.angle;
						SelfLight1.pitch = owner.pitch;
						SelfLight1.spring = spring;
						SelfLight1.damping = damping;
						SelfLight1.inertia = inertia;
						SelfLight1.offsetAngle = offsetAngle;
						SelfLight1.offsetZ = offsetZ;
					
			
					if(!SelfLight1) {
						SelfLight1 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight1.FollowTarget = owner;
						SelfLight1.args[DynamicLight.LIGHT_RED] = R; //R
						SelfLight1.args[DynamicLight.LIGHT_GREEN] = G; //G
						SelfLight1.args[DynamicLight.LIGHT_BLUE] = B; //B
						SelfLight1.args[DynamicLight.LIGHT_INTENSITY] = beamRadius; //Radius
						SelfLight1.SpotInnerAngle = beamInner;
						SelfLight1.SpotOuterAngle = beamOuter;
						SelfLight1.angle = owner.angle;
						SelfLight1.pitch = owner.pitch;
						SelfLight1.spring = spring;
						SelfLight1.damping = damping;
						SelfLight1.inertia = inertia;
						SelfLight1.offsetAngle = offsetAngle;
						SelfLight1.offsetZ = offsetZ;
					
				
						SelfLight2 = BDP_Spotlight(Spawn("BDP_Spotlight",owner.pos,false));
						SelfLight2.FollowTarget = owner;
						SelfLight2.args[DynamicLight.LIGHT_RED] = int(R * 0.75); //R
						SelfLight2.args[DynamicLight.LIGHT_GREEN] = int(G * 0.75); //G
						SelfLight2.args[DynamicLight.LIGHT_BLUE] = int(B * 0.75); //B
						SelfLight2.args[DynamicLight.LIGHT_INTENSITY] = spillRadius; //Radius
						SelfLight2.SpotInnerAngle = spillInner;
						SelfLight2.SpotOuterAngle = spillOuter;
						SelfLight2.angle = owner.angle;
						SelfLight2.pitch = owner.pitch;
						SelfLight2.spring = spring;
						SelfLight2.damping = damping;
						SelfLight2.inertia = inertia;
						SelfLight2.offsetAngle = offsetAngle;
						SelfLight2.offsetZ = offsetZ;
					
			}
		}
		else {
			if(SelfLight1) { SelfLight1.Destroy(); }
			if(SelfLight2) { SelfLight2.Destroy(); }
		}
		if (level.time % 5 == 0)
		{
			FLineTraceData AlertTrace;
			owner.LineTrace(Owner.Angle, 328, owner.pitch, TRF_SOLIDACTORS, owner.height * 0.5, data: AlertTrace);
		
			let alerter = Spawn("flashlightalert",alerttrace.hitlocation);
			If(alerter)
			{
				Alerter.target = owner;
				Alerter.a_alertmonsters(150);
			}
		}
		
	}

	States {
	Spawn:
		ROCK A -1;
		stop;
Use:
		TNT1 A 1;
		loop;
	}


}


class BDP_Spotlight : DynamicLight {
	actor FollowTarget;
	double vela, velp;
	double spring, damping;
	double offsetAngle, offsetZ;
	vector3 targetPos;
	int inertia;

	default {
		DynamicLight.Type "Point";
		+DYNAMICLIGHT.ATTENUATE;
		+DYNAMICLIGHT.SPOT
	}
	override void Tick() {
		super.Tick();
		if(followTarget && followTarget.player) {
			if(inertia == 0) inertia = 1;
			targetpos = followTarget.vec3Angle(
				2 + (6 * abs(sin(offsetAngle))),
				followtarget.angle + offsetAngle,
				followtarget.player.viewheight + offsetZ,
				false);
			vel.x += DampedSpring(pos.x, targetpos.x, vel.x, 1, 1);
			vel.y += DampedSpring(pos.y, targetpos.y, vel.y, 1, 1);
			vel.z += DampedSpring(pos.z, targetpos.z, vel.z, 1, 1);
			vela  += DampedSpring(angle, followTarget.angle, vela, spring, damping);
			velp  += DampedSpring(pitch, followTarget.pitch, velp, spring, damping);
			setOrigin(pos + vel, true);
			A_SetAngle(angle + (vela / inertia), true);
			A_SetPitch(pitch + (velp / inertia), true);
		}
	}

	double DampedSpring(double p, double r, double v, double k, double d) {
		return -(d * v) - (k * (p - r));
	}
}


Class FlashlightAlert : Actor
{
	Default
	{
		projectile;
	}
	
	States
	{
		Spawn:
			TNT1 A 1;
			STOP;
	
	}
}

Class ScannerEffect : Actor
{
	Int scalevalue;
		Default
			{
				+nogravity;
				renderradius 2000;
				Alpha 0.2;
			}
			States
			{
				Spawn:
					NUKF A 1 BRIGHT
					{
					scalevalue = (scalevalue + 45);
					A_setscale(scalevalue,scalevalue);
					A_fadeout(0.002);
					}
					LOOP;
			}
}